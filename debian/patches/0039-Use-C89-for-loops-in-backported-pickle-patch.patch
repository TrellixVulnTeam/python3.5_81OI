From: Anthony Sottile <asottile@umich.edu>
Date: Fri, 29 Mar 2019 14:32:49 -0700
Subject: Use C89 for loops in backported pickle patch

---
 Modules/_pickle.c | 11 +++++++----
 1 file changed, 7 insertions(+), 4 deletions(-)

diff --git a/Modules/_pickle.c b/Modules/_pickle.c
index fcb9e87..3b4003f 100644
--- a/Modules/_pickle.c
+++ b/Modules/_pickle.c
@@ -658,6 +658,7 @@ PyMemoTable_New(void)
 static PyMemoTable *
 PyMemoTable_Copy(PyMemoTable *self)
 {
+    size_t i;
     PyMemoTable *new = PyMemoTable_New();
     if (new == NULL)
         return NULL;
@@ -674,7 +675,7 @@ PyMemoTable_Copy(PyMemoTable *self)
         PyErr_NoMemory();
         return NULL;
     }
-    for (size_t i = 0; i < self->mt_allocated; i++) {
+    for (i = 0; i < self->mt_allocated; i++) {
         Py_XINCREF(self->mt_table[i].me_key);
     }
     memcpy(new->mt_table, self->mt_table,
@@ -4198,13 +4199,14 @@ static PyObject *
 _pickle_PicklerMemoProxy_copy_impl(PicklerMemoProxyObject *self)
 /*[clinic end generated code: output=bb83a919d29225ef input=b73043485ac30b36]*/
 {
+    size_t i;
     PyMemoTable *memo;
     PyObject *new_memo = PyDict_New();
     if (new_memo == NULL)
         return NULL;
 
     memo = self->pickler->memo;
-    for (size_t i = 0; i < memo->mt_allocated; ++i) {
+    for (i = 0; i < memo->mt_allocated; ++i) {
         PyMemoEntry entry = memo->mt_table[i];
         if (entry.me_key != NULL) {
             int status;
@@ -6773,6 +6775,7 @@ Unpickler_get_memo(UnpicklerObject *self)
 static int
 Unpickler_set_memo(UnpicklerObject *self, PyObject *obj)
 {
+    size_t i;
     PyObject **new_memo;
     size_t new_memo_size = 0;
 
@@ -6791,7 +6794,7 @@ Unpickler_set_memo(UnpicklerObject *self, PyObject *obj)
         if (new_memo == NULL)
             return -1;
 
-        for (size_t i = 0; i < new_memo_size; i++) {
+        for (i = 0; i < new_memo_size; i++) {
             Py_XINCREF(unpickler->memo[i]);
             new_memo[i] = unpickler->memo[i];
         }
@@ -6839,7 +6842,7 @@ Unpickler_set_memo(UnpicklerObject *self, PyObject *obj)
 
   error:
     if (new_memo_size) {
-        for (size_t i = new_memo_size - 1; i != SIZE_MAX; i--) {
+        for (i = new_memo_size - 1; i != SIZE_MAX; i--) {
             Py_XDECREF(new_memo[i]);
         }
         PyMem_FREE(new_memo);
